
# Generated by stc version 0.7.4
# date                    : 2018/06/19 16:28:52
# Turbine version         : 1.1.0
# Input filename          : /home/tshu/project/Cluster2018/workflow-0/workflow-2.swift
# Output filename         : /home/tshu/project/Cluster2018/workflow-0
# STC home                : /home/tshu/software/swift-t/stc
# Turbine home            : /home/tshu/software/swift-t/turbine
# Compiler settings:
# stc.auto-declare              : true
# stc.c_preprocess              : true
# stc.checkpointing             : true
# stc.compiler-debug            : true
# stc.debugging                 : COMMENTS
# stc.ic.output-file            : 
# stc.input_filename            : workflow-2.swift
# stc.log.file                  : 
# stc.log.trace                 : false
# stc.must_pass_wait_vars       : true
# stc.opt.algebra               : true
# stc.opt.array-build           : true
# stc.opt.batch-refcounts       : true
# stc.opt.cancel-refcounts      : true
# stc.opt.constant-fold         : true
# stc.opt.controlflow-fusion    : true
# stc.opt.dataflow-op-inline    : true
# stc.opt.dead-code-elim        : true
# stc.opt.demote-globals        : true
# stc.opt.disable-asserts       : false
# stc.opt.expand-loop-threshold-insts: 256
# stc.opt.expand-loop-threshold-iters: 16
# stc.opt.expand-loops          : false
# stc.opt.finalized-var         : true
# stc.opt.flatten-nested        : true
# stc.opt.full-function-inline  : false
# stc.opt.full-unroll           : false
# stc.opt.function-always-inline-threshold: 5
# stc.opt.function-inline       : true
# stc.opt.function-inline-threshold: 50
# stc.opt.function-signature    : true
# stc.opt.hoist                 : true
# stc.opt.hoist-refcounts       : true
# stc.opt.loop-simplify         : true
# stc.opt.max-iterations        : 10
# stc.opt.merge-refcounts       : true
# stc.opt.piggyback-refcounts   : true
# stc.opt.pipeline              : false
# stc.opt.propagate-aliases     : true
# stc.opt.reorder-insts         : false
# stc.opt.shared-constants      : true
# stc.opt.unroll-loop-threshold-insts: 192
# stc.opt.unroll-loop-threshold-iters: 8
# stc.opt.unroll-loops          : true
# stc.opt.value-number          : true
# stc.opt.wait-coalesce         : true
# stc.output_filename           : 
# stc.preproc.force-cpp         : false
# stc.preproc.force-gcc         : false
# stc.preprocess_only           : false
# stc.profile                   : false
# stc.refcounting               : true
# stc.rpath                     : 
# stc.stc_home                  : /home/tshu/software/swift-t/stc
# stc.turbine.version           : 1.1.0
# stc.turbine_home              : /home/tshu/software/swift-t/turbine
# stc.version                   : 0.7.4

# Metadata:

package require turbine 1.1.0
namespace import turbine::*


proc swift:constants {  } {
    turbine::c::log "function:swift:constants"
}


proc swift:main {  } {
    turbine::c::log "function: __entry"
    # Var: string[int] u:param_array RENAMED [string[int]:param_array] workflow-2.swift:main():172:4
    lassign [ adlb::multicreate [ list container integer string 1 256 1 ] ] u:param_array
    turbine::c::log "allocated u:param_array=<${u:param_array}>"
    turbine::rule [ list ${u:param_array} ] "main-foreach-wait1 ${u:param_array}"
    get_param_array-range1:outer ${u:param_array} 1 4 1
}


proc main-foreach-wait1 { u:param_array } {
    set tcltmp:container_sz [ adlb::enumerate ${u:param_array} count all 0 ]
    set tcltmp:iters ${tcltmp:container_sz}
    turbine::read_refcount_incr ${u:param_array} [ expr { ${tcltmp:iters} - 1 } ]
    main-foreach1:outer ${u:param_array} 0 [ expr { ${tcltmp:container_sz} - 1 } ] 1
}


proc main-foreach1:outer { u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    if { [ expr { ${tcltmp:lo} > ${tcltmp:hi} } ] } {
        return
    }
    while {1} {
        set tcltmp:itersleft [ expr { max(0,(${tcltmp:hi} - ${tcltmp:lo}) / ${tcltmp:inc} + 1) } ]
        if { [ expr { ${tcltmp:itersleft} <= 64 } ] } {
            main-foreach1:inner ${u:param_array} ${tcltmp:lo} ${tcltmp:hi} ${tcltmp:inc}
            return
        } else {
            set tcltmp:skip [ expr { ${tcltmp:inc} * max(64,((${tcltmp:itersleft} - 1) / 16) + 1) } ]
            for { set tcltmp:splitstart [ expr { ${tcltmp:lo} + ${tcltmp:skip} } ] } { ${tcltmp:splitstart} <= ${tcltmp:hi} } { incr tcltmp:splitstart ${tcltmp:skip} } {
                set tcltmp:splitend [ expr { min(${tcltmp:hi},${tcltmp:splitstart} + ${tcltmp:skip} - 1) } ]
                set tcltmp:prio [ turbine::get_priority ]
                turbine::set_priority ${tcltmp:prio}
                adlb::spawn 0 "main-foreach1:outer ${u:param_array} ${tcltmp:splitstart} ${tcltmp:splitend} ${tcltmp:inc}"
                turbine::reset_priority
            }
            set tcltmp:hi [ expr { ${tcltmp:lo} + ${tcltmp:skip} - 1 } ]
        }
    }
}


proc main-foreach1:inner { u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    set tcltmp:splitlen [ expr { ${tcltmp:hi} - ${tcltmp:lo} + 1 } ]
    set tcltmp:contents [ adlb::enumerate ${u:param_array} dict ${tcltmp:splitlen} ${tcltmp:lo} ]
    dict for {v:j v:p} ${tcltmp:contents} {
        set tcltmp:prio [ turbine::get_priority ]
        turbine::set_priority ${tcltmp:prio}
        adlb::spawn 0 [ list __entry-call_foreign-printf ${v:p} ]
        turbine::reset_priority
    }
    set tcltmp:iters [ expr { max(0,(${tcltmp:hi} - ${tcltmp:lo}) / ${tcltmp:inc} + 1) } ]
    turbine::read_refcount_decr ${u:param_array} [ expr { ${tcltmp:iters} } ]
}


proc __entry-call_foreign-printf { v:p } {
    # Var: $void v:t:1:6 VALUE_OF [void:__t:1:6]
    set v:t:1:6 [ turbine::printf_local "p = %s" ${v:p} ]
}


proc get_param_array-range1:outer { u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    if { [ expr { ${tcltmp:lo} > ${tcltmp:hi} } ] } {
        return
    }
    while {1} {
        set tcltmp:itersleft [ expr { max(0,(${tcltmp:hi} - ${tcltmp:lo}) / ${tcltmp:inc} + 1) } ]
        if { [ expr { ${tcltmp:itersleft} <= 64 } ] } {
            get_param_array-range1:inner ${u:param_array} ${tcltmp:lo} ${tcltmp:hi} ${tcltmp:inc}
            return
        } else {
            set tcltmp:skip [ expr { ${tcltmp:inc} * max(64,((${tcltmp:itersleft} - 1) / 16) + 1) } ]
            for { set tcltmp:splitstart [ expr { ${tcltmp:lo} + ${tcltmp:skip} } ] } { ${tcltmp:splitstart} <= ${tcltmp:hi} } { incr tcltmp:splitstart ${tcltmp:skip} } {
                set tcltmp:splitend [ expr { min(${tcltmp:hi},${tcltmp:splitstart} + ${tcltmp:skip} - 1) } ]
                set tcltmp:prio [ turbine::get_priority ]
                turbine::set_priority ${tcltmp:prio}
                adlb::spawn 0 "get_param_array-range1:outer ${u:param_array} ${tcltmp:splitstart} ${tcltmp:splitend} ${tcltmp:inc}"
                turbine::reset_priority
            }
            set tcltmp:hi [ expr { ${tcltmp:lo} + ${tcltmp:skip} - 1 } ]
        }
    }
}


proc get_param_array-range1:inner { u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    for { set v:ht_procs_x1 ${tcltmp:lo} } { ${v:ht_procs_x1} <= ${tcltmp:hi} } { incr v:ht_procs_x1 ${tcltmp:inc} } {
        # Var: $int v:t:14:1 VALUE_OF [int:__t:14:1]
        # Var: $int v:t:13:1 VALUE_OF [int:__t:13:1]
        # Var: $int v:t:12:1 VALUE_OF [int:__t:12:1]
        set v:t:14:1 [ expr { ${v:ht_procs_x1} - 1 } ]
        set v:t:13:1 [ expr { ${v:t:14:1} * 4 } ]
        set v:t:12:1 [ expr { ${v:t:13:1} * 16 } ]
        get_param_array-range2:outer ${v:ht_procs_x1} ${v:t:12:1} ${u:param_array} 1 4 1
    }
}


proc get_param_array-range2:outer { v:ht_procs_x1 v:t:12:1 u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    if { [ expr { ${tcltmp:lo} > ${tcltmp:hi} } ] } {
        return
    }
    while {1} {
        set tcltmp:itersleft [ expr { max(0,(${tcltmp:hi} - ${tcltmp:lo}) / ${tcltmp:inc} + 1) } ]
        if { [ expr { ${tcltmp:itersleft} <= 64 } ] } {
            get_param_array-range2:inner ${v:ht_procs_x1} ${v:t:12:1} ${u:param_array} ${tcltmp:lo} ${tcltmp:hi} ${tcltmp:inc}
            return
        } else {
            set tcltmp:skip [ expr { ${tcltmp:inc} * max(64,((${tcltmp:itersleft} - 1) / 16) + 1) } ]
            for { set tcltmp:splitstart [ expr { ${tcltmp:lo} + ${tcltmp:skip} } ] } { ${tcltmp:splitstart} <= ${tcltmp:hi} } { incr tcltmp:splitstart ${tcltmp:skip} } {
                set tcltmp:splitend [ expr { min(${tcltmp:hi},${tcltmp:splitstart} + ${tcltmp:skip} - 1) } ]
                set tcltmp:prio [ turbine::get_priority ]
                turbine::set_priority ${tcltmp:prio}
                adlb::spawn 0 "get_param_array-range2:outer ${v:ht_procs_x1} ${v:t:12:1} ${u:param_array} ${tcltmp:splitstart} ${tcltmp:splitend} ${tcltmp:inc}"
                turbine::reset_priority
            }
            set tcltmp:hi [ expr { ${tcltmp:lo} + ${tcltmp:skip} - 1 } ]
        }
    }
}


proc get_param_array-range2:inner { v:ht_procs_x1 v:t:12:1 u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    for { set v:ht_procs_y2 ${tcltmp:lo} } { ${v:ht_procs_y2} <= ${tcltmp:hi} } { incr v:ht_procs_y2 ${tcltmp:inc} } {
        # Var: $int v:t:19:1 VALUE_OF [int:__t:19:1]
        # Var: $int v:t:18:1 VALUE_OF [int:__t:18:1]
        # Var: $int v:t:11:1 VALUE_OF [int:__t:11:1]
        set v:t:19:1 [ expr { ${v:ht_procs_y2} - 1 } ]
        set v:t:18:1 [ expr { ${v:t:19:1} * 16 } ]
        set v:t:11:1 [ expr { ${v:t:12:1} + ${v:t:18:1} } ]
        get_param_array-range3:outer ${v:ht_procs_x1} ${v:ht_procs_y2} ${v:t:11:1} ${u:param_array} 1 16 1
    }
}


proc get_param_array-range3:outer { v:ht_procs_x1 v:ht_procs_y2 v:t:11:1 u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    if { [ expr { ${tcltmp:lo} > ${tcltmp:hi} } ] } {
        return
    }
    while {1} {
        set tcltmp:itersleft [ expr { max(0,(${tcltmp:hi} - ${tcltmp:lo}) / ${tcltmp:inc} + 1) } ]
        if { [ expr { ${tcltmp:itersleft} <= 64 } ] } {
            get_param_array-range3:inner ${v:ht_procs_x1} ${v:ht_procs_y2} ${v:t:11:1} ${u:param_array} ${tcltmp:lo} ${tcltmp:hi} ${tcltmp:inc}
            return
        } else {
            set tcltmp:skip [ expr { ${tcltmp:inc} * max(64,((${tcltmp:itersleft} - 1) / 16) + 1) } ]
            for { set tcltmp:splitstart [ expr { ${tcltmp:lo} + ${tcltmp:skip} } ] } { ${tcltmp:splitstart} <= ${tcltmp:hi} } { incr tcltmp:splitstart ${tcltmp:skip} } {
                set tcltmp:splitend [ expr { min(${tcltmp:hi},${tcltmp:splitstart} + ${tcltmp:skip} - 1) } ]
                set tcltmp:prio [ turbine::get_priority ]
                turbine::set_priority ${tcltmp:prio}
                adlb::spawn 0 "get_param_array-range3:outer ${v:ht_procs_x1} ${v:ht_procs_y2} ${v:t:11:1} ${u:param_array} ${tcltmp:splitstart} ${tcltmp:splitend} ${tcltmp:inc}"
                turbine::reset_priority
            }
            set tcltmp:hi [ expr { ${tcltmp:lo} + ${tcltmp:skip} - 1 } ]
        }
    }
}


proc get_param_array-range3:inner { v:ht_procs_x1 v:ht_procs_y2 v:t:11:1 u:param_array tcltmp:lo tcltmp:hi tcltmp:inc } {
    for { set v:sw_procs3 ${tcltmp:lo} } { ${v:sw_procs3} <= ${tcltmp:hi} } { incr v:sw_procs3 ${tcltmp:inc} } {
        # Var: $int v:t:10:1 VALUE_OF [int:__t:10:1]
        # Var: $int v:i VALUE_OF [int:i]
        # Var: $string v:t:23:1 VALUE_OF [string:__t:23:1]
        set v:t:10:1 [ expr { ${v:t:11:1} + ${v:sw_procs3} } ]
        set v:i [ expr { ${v:t:10:1} - 1 } ]
        set v:t:23:1 [ turbine::sprintf_impl "{\"ht_procs_x\":%i,\"ht_procs_y\":%i,\"sw_procs\":%i}" ${v:ht_procs_x1} ${v:ht_procs_y2} ${v:sw_procs3} ]
        turbine::container_insert ${u:param_array} ${v:i} ${v:t:23:1} string 1
    }
}

turbine::defaults
turbine::declare_custom_work_types COASTER
turbine::init $servers "Swift"
turbine::enable_read_refcount
adlb::declare_struct_type 16 s:location [ list "rank" integer "strictness" string "accuracy" string ]
adlb::declare_struct_type 17 s:PartialStats [ list "n" integer "mean" float "M2" float ]
turbine::check_constants "WORKER\[WORKER\]" ${turbine::WORK_TASK} 0 "CONTROL" ${turbine::WORK_TASK} 0 "ADLB_RANK_ANY" ${adlb::RANK_ANY} -100
adlb::add_debug_symbol 1 "param_array" "workflow-2:main():172:4"
turbine::start swift:main swift:constants
turbine::finalize
